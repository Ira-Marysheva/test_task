/****************************************************************
Описание
	Вам дается квадратная сетка с обычными `.` и заблокированными `X` ячейками. 
  Ваша игровая фигура может перемещаться по любой строке или столбцу или диагонали, пока не достигнет края сетки или заблокированной ячейки. 
  Учитывая сетку, начальную и конечную позиции, постройте кратчайший путь, чтобы добраться до конечной позиции.

Например
	Дана сетка:
  .X.
  .X.
  ...

  Система координаты для данной сетки:
  0.0 0.1 0.2
  1.0 1.1	1.2
  2.0	2.1	2.2

  Начальна позиция 2.1 (отсчет идет с верхнего левого края сетки 0.0)
  Конечная позиция 0.2

  Путь движения между начальной и конечной точкой: (2.1) -> (1.2) -> (0.2)
  Ответ: [{x:2, y:1}, {x:1, y:2}, {x:0, y:2}]

	Задача
  	Завершите выполнение функции в редакторе. Функция должена вывести массив объектов координат которые обеспечивают минимальное количество шагов для перехода от начальной позиции к конечной и порядок массива соответвует движения по координатам.

  Ограничения
  	Длина сетки > 1 и < 100
    Координата начальной и конечной точки входит в предоставленную сетку.
    Задача должна быть решена с использованием ООП
    Плюсом будет использоватие TypeScript
  	
****************************************************************/

type Point = {
	x: number;
  y: number;
  visited?: boolean, //  Поле для перевірки відвідуваності
  path?: Point[] // Поле для зберігання шляху
};

function runner(gridList: string[], start: Point, end: Point): Point[] {
		const matrix = gridList.map(row => row.split(''));
    
    let queue: Point[] = [{ ...start, path: [start] }]; // Ініціалізуємо чергу з початковою точкою

    while (queue.length > 0) {
        let point: Point | undefined = queue.shift();
        if (!point) continue; // Якщо point undefined, пропустити ітерацію

        // Перевірка, чи досягли кінцевої точки
        if (point.x === end.x && point.y === end.y) {
          // for $('#result').text(result); return JSON.stringify(point.path) //формат строки
            return point.path; // Повертаємо шлях до кінцевої точки 
        }

        // Встановлюємо visited перед перевіркою сусідів
        point.visited = true;
        for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            // Пропускаємо саму точку
            if (i === 0 && j === 0) continue;
            // Перевірка меж
            const newX = point.x + i;
            const newY = point.y + j;

            if (newX >= 0 && newX < gridList.length && newY >= 0 && newY < gridList[0].length) {
                // Перевірка на перешкоду
                if (gridList[newX][newY] === 'X') continue;
                // Перевірка на відвіданість
                if (!queue.some(p => p.x === newX && p.y === newY)) {
                    // Додаємо нову точку з копією шляху
                    queue.push({ x: newX, y: newY, path: [...point.path, { x: newX, y: newY }] });
                }
            }
        }
    }
    }
     // for $('#result').text(result); return JSON.stringify([]) //формат строки
    return []; // Якщо шлях не знайдено, повертаємо порожній масив 
}

const result = runner(
  [
    '.X.',
    '.X.',
    '...',
  ], 
  { x: 2, y: 1 },
  { x: 0, y: 2 }
);
console.log(result); // [{x:2, y:1}, {x:1, y:2}, {x:0, y:2}]